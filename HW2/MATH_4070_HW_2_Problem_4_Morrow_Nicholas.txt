
% MATH 4070
% HW 2
% Problem 4
% By Nicholas Morrow

% Define the function to be approximated
f = @(t) exp(sin(t));

% Define the interval
t_0 = 0;
t_n = 2*pi;

% Define the degrees of the trigonometric polynomials
N_values = [1, 3, 5];
max_N = max(N_values);

% Create a grid of t-values for plotting, 1000 points
t_plot = linspace(t_0, t_n, 1000).';

% Prepare for looping over each N value, each col will have a polynomial
P_N = zeros(numel(t_plot), numel(N_values));

% first coefficient is the same for all N
a0 = (1/pi) * integral(@(t) f(t), t_0, t_n)

a0 =

    2.5321


% Loop through each required degree N
for i = 1:numel(N_values)
    % Prepare before summation
    N = N_values(i);
    ak = zeros(1,N);
    bk = zeros(1,N);
    % By def of degree-N real trigonometric polynomial, a0/2 will be included in each calculation
    polyVals = a0 / 2 * ones(size(t_plot));

    for k = 1:N
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

  -1.7670e-17

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end

    % Store
    P_N(:,i) = polyVals;
end
    % Prepare before summation
    N = N_values(i);
    ak = zeros(1,N);
    bk = zeros(1,N);
    % By def of degree-N real trigonometric polynomial, a0/2 will be included in each calculation
    polyVals = a0 / 2 * ones(size(t_plot));

    for k = 1:N
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   1.0e-16 *

   -0.1767         0         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303         0         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715   -0.0000

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000   -0.0443


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end

    % Store
    P_N(:,i) = polyVals;
end
    % Prepare before summation
    N = N_values(i);
    ak = zeros(1,N);
    bk = zeros(1,N);
    % By def of degree-N real trigonometric polynomial, a0/2 will be included in each calculation
    polyVals = a0 / 2 * ones(size(t_plot));

    for k = 1:N
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   1.0e-16 *

   -0.1767         0         0         0         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303         0         0         0         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715         0         0         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000         0         0         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715   -0.0000         0         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000   -0.0443         0         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715   -0.0000    0.0055         0

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000   -0.0443    0.0000         0


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end
        % Fourier coeffs (1/pi)integ(f(t)cos(kt)dt) and (1/pi)integ(f(t)sin(kt)dt)
        ak(k) = (1/pi) * integral(@(t) f(t).*cos(k*t), t_0, t_n)

ak =

   -0.0000   -0.2715   -0.0000    0.0055   -0.0000

        bk(k) = (1/pi) * integral(@(t) f(t).*sin(k*t), t_0, t_n)

bk =

    1.1303    0.0000   -0.0443    0.0000    0.0005


        polyVals = polyVals + ak(k)*cos(k*t_plot) + bk(k)*sin(k*t_plot);
    end

    % Store
    P_N(:,i) = polyVals;
end

% Plot
figure(1);

% Original function
plot(t_plot, f(t_plot), 'w');  hold on;

% Approximations
plot(t_plot, P_N(:,1), 'r--');   % N = 1, red
plot(t_plot, P_N(:,2), 'b-.');   % N = 3, blue
plot(t_plot, P_N(:,3), 'g:');   % N = 5, green

% Extra thing(s) for plot
xlim([t_0 t_n]);
title('Approximation of f(t) = e^{sin(t)} by Trigonometric Polynomials');
xlabel('t');
ylabel('f(t), p_N(t)');
legend('f(t) = e^{sin(t)}', 'N = 1', 'N = 3', 'N = 5', 'Location', 'northeast');
axis tight;


% Wasn't sure if I needed a creation line, uncomment to make the pdf if you want
% print(gcf,'-dpdf','MATH_4070_HW_2_Problem_4_Morrow_Nicholas_plot.pdf')

diary off
